# -*- coding: utf-8 -*-
"""Financial_AI_Agent_.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Yb08E-3NkoyYudrLNIFT2jry4gWgqg65
"""

# ‚úÖ 1. INSTALL DEPENDENCIES
!pip install -U langchain langchain-community openai-whisper vosk sentence-transformers faiss-cpu chromadb flask-ngrok fpdf2
!sudo apt update && sudo apt install ffmpeg -y

import os
#Create necessary directories
folders = [
    "modules",
    "modules/finance_apis",
    "data/uploaded_files",
    "data/vector_store/faiss_index",  # FAISS will save here
    "logs",
    "pdf_reports",
    "audio_samples"  # in case you want voice interaction
]
for folder in folders:
    os.makedirs(folder, exist_ok=True)
# Set environment variables (for things like API keys)
os.environ["ALPHA_VANTAGE_API_KEY"] = "LU1ZRAF1HR2V83BK"

# ‚úÖ 3. DATABASE SETUP
import sqlite3
conn = sqlite3.connect("logs/activity_log.db")
cursor = conn.cursor()
cursor.execute('''CREATE TABLE IF NOT EXISTS logs (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    timestamp TEXT,
    intent TEXT,
    input_text TEXT,
    response TEXT,
    metadata TEXT
)''')
conn.commit()
conn.close()

# Commented out IPython magic to ensure Python compatibility.
# # ‚úÖ 4. MODULE: speech_to_text.py
# %%writefile modules/speech_to_text.py
# import whisper
# model = whisper.load_model("base")
# def transcribe_audio(audio_path):
#     result = model.transcribe(audio_path)
#     return result['text']

# Commented out IPython magic to ensure Python compatibility.
# # ‚úÖ 5. MODULE: intent_recognizer.py
# %%writefile modules/intent_recognizer.py
# from sentence_transformers import SentenceTransformer, util
# import re
# model = SentenceTransformer('sentence-transformers/all-MiniLM-L6-v2')
# 
# intent_map = {
#     "check account balance": "get_account_balance",
#     "generate tax report": "generate_tax_report",
#     "upload and process invoice": "upload_invoice",
#     "fetch cashflow summary": "get_cashflow_summary"
# }
# keyword_map = {
#     "balance": "get_account_balance",
#     "tax": "generate_tax_report",
#     "invoice": "upload_invoice",
#     "cashflow": "get_cashflow_summary",
#     "cash flow": "get_cashflow_summary"
# }
# def get_intent(user_query):
#     queries = list(intent_map.keys())
#     embeddings = model.encode(queries + [user_query], convert_to_tensor=True)
#     similarity = util.pytorch_cos_sim(embeddings[-1], embeddings[:-1])
#     best_idx = similarity.argmax()
#     best_score = similarity[0][best_idx].item()
#     if best_score >= 0.5:
#         return intent_map[queries[best_idx]]
#     lowered = user_query.lower()
#     for keyword, intent in keyword_map.items():
#         if re.search(rf"\\b{keyword}\\b", lowered):
#             return intent
#     return "unknown_intent"

# Commented out IPython magic to ensure Python compatibility.
# # ‚úÖ modules/file_parser.py
# %%writefile modules/file_parser.py
# import pandas as pd
# import sqlite3
# import os
# from datetime import datetime
# import re
# 
# def sanitize_column_name(name):
#     """Remove special characters and convert to snake_case."""
#     return re.sub(r'\W+', '_', str(name).strip().lower())
# 
# def parse_and_store(file_path):
#     if not os.path.exists(file_path):
#         raise FileNotFoundError(f"File not found: {file_path}")
# 
#     # Read Excel file and get first row as header
#     df = pd.read_excel(file_path)
# 
#     # Sanitize column names to be SQLite-compatible
#     original_columns = df.columns
#     sanitized_columns = [sanitize_column_name(col) for col in original_columns]
#     df.columns = sanitized_columns
# 
#     # Create dynamic table name
#     timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
#     table_name = f"financial_data_{timestamp}"
# 
#     # Create SQLite connection
#     conn = sqlite3.connect("data/financial_data.db")
#     cursor = conn.cursor()
# 
#     # Generate CREATE TABLE statement dynamically
#     create_table_sql = f"CREATE TABLE IF NOT EXISTS `{table_name}` (\n  id INTEGER PRIMARY KEY AUTOINCREMENT,"
#     for col in sanitized_columns:
#         create_table_sql += f"\n  `{col}` TEXT,"
#     create_table_sql = create_table_sql.rstrip(',') + "\n);"
# 
#     cursor.execute(create_table_sql)
# 
#     # Insert all rows into the table
#     df.to_sql(table_name, conn, if_exists='append', index=False)
# 
#     conn.commit()
#     conn.close()
# 
#     return table_name, sanitized_columns
#

# Commented out IPython magic to ensure Python compatibility.
# # ‚úÖ 7. MODULE: rag_retriever.py
# %%writefile modules/rag_retriever.py
# import os
# from langchain_community.vectorstores import FAISS
# from langchain_community.embeddings import HuggingFaceEmbeddings
# from langchain.schema import Document
# import whisper
# 
# # üîÅ PATHS
# FAISS_PATH = "data/vector_store/faiss_index"
# 
# # ------------------ PART 1: General Knowledge Setup ------------------
# 
# def get_general_finance_knowledge():
#     """
#     Predefined general finance knowledge base.
#     """
#     texts = [
#         "The primary goal of financial management is to maximize shareholder wealth by making sound investment and financing decisions.",
#         "Financial statements include the balance sheet, income statement, and cash flow statement.",
#         "The balance sheet provides a snapshot of a company‚Äôs financial position at a specific point in time.",
#         "Cash flow statements show the inflows and outflows of cash, categorized into operating, investing, and financing activities.",
#         "Profitability ratios such as gross margin and net profit margin help assess a company‚Äôs financial performance.",
#         "Working capital management involves managing current assets and liabilities to ensure a company can meet its short-term obligations.",
#         "Capital budgeting is the process of evaluating and selecting long-term investments that are in line with the firm's goal of shareholder wealth maximization.",
#     ]
#     return [Document(page_content=text) for text in texts]
# 
# def setup_general_vector_store():
#     """
#     Embed and store general finance knowledge into FAISS.
#     """
#     documents = get_general_finance_knowledge()
#     return setup_vector_store(documents)
# 
# # ------------------ PART 2: Document Embedding & Search ------------------
# 
# def setup_vector_store(documents, save_index=True):
#     """
#     Embed documents and store them in FAISS vector DB.
#     """
#     embed = HuggingFaceEmbeddings(model_name="sentence-transformers/all-MiniLM-L6-v2")
#     db = FAISS.from_documents(documents, embed)
#     if save_index:
#         save_vector_store(db)
#     return db
# 
# def save_vector_store(vector_store):
#     """
#     Save the FAISS vector store to local path.
#     """
#     vector_store.save_local(FAISS_PATH)
# 
# def load_vector_store():
#     """
#     Load FAISS vector store from local path.
#     """
#     index_path = os.path.join(FAISS_PATH, "index.faiss")
#     if os.path.exists(index_path):
#         embed = HuggingFaceEmbeddings(model_name="sentence-transformers/all-MiniLM-L6-v2")
#         try:
#             return FAISS.load_local(FAISS_PATH, embed, allow_dangerous_deserialization=True)
#         except Exception as e:
#             print("‚ö†Ô∏è Failed to load FAISS index:", e)
#             return None
#     else:
#         return None
# 
# def query_vector_store(question, vector_store=None, k=1):
#     """
#     Perform semantic search with the input question.
#     """
#     if not vector_store:
#         vector_store = load_vector_store()
#         if not vector_store:
#             print("üß† No user-uploaded vector store found. Using general financial knowledge base...")
#             vector_store = setup_general_vector_store()
# 
#     result = vector_store.similarity_search(question, k=k)
#     return result[0].page_content if result else "‚ùå No relevant information found."
# 
# # ------------------ PART 3: Audio Input ‚Üí Semantic Answer ------------------
# 
# def transcribe_audio(audio_path):
#     """
#     Transcribe speech to text using OpenAI Whisper.
#     """
#     try:
#         model = whisper.load_model("base")  # Options: tiny, base, small, medium, large
#         result = model.transcribe(audio_path)
#         return result['text']
#     except Exception as e:
#         return f"‚ùå Failed to transcribe audio: {e}"
# 
# def query_from_audio(audio_path):
#     """
#     Convert audio ‚Üí question ‚Üí vector search ‚Üí answer.
#     """
#     question = transcribe_audio(audio_path)
#     if "‚ùå" in question:
#         return question
#     print(f"üé§ Transcribed Question: {question}")
#     return query_vector_store(question)
#

# Commented out IPython magic to ensure Python compatibility.
# # ‚úÖ 8. MODULE: logger.py
# %%writefile logs/logger.py
# import sqlite3
# from datetime import datetime
# import json
# 
# def log_to_db(intent, input_text, response, metadata=""):
#     conn = sqlite3.connect("logs/activity_log.db")
#     cursor = conn.cursor()
#     cursor.execute("""
#         INSERT INTO logs (timestamp, intent, input_text, response, metadata)
#         VALUES (?, ?, ?, ?, ?)""",
#         (str(datetime.now()), intent, input_text, json.dumps(response), metadata))
#     conn.commit()
#     conn.close()

# Commented out IPython magic to ensure Python compatibility.
# # ‚úÖ 9. MODULE: finance_apis/cash_management.py
# # ========================================
# %%writefile modules/finance_apis/cash_management.py
# import requests, os
# def get_summary():
#     api_key = os.getenv("ALPHA_VANTAGE_API_KEY")
#     url = f"https://www.alphavantage.co/query?function=CASH_FLOW&symbol=AAPL&apikey={api_key}"
#     response = requests.get(url)
#     data = response.json()
#     try:
#         report = data['annualReports'][0]
#         cash = report['cashAndCashEquivalentsAtCarryingValue']
#         return {"total_cash": f"${cash}", "available_cash": f"${cash}"}
#     except Exception as e:
#         return {"error": str(e)}

# Commented out IPython magic to ensure Python compatibility.
# # ‚úÖ 10. MODULE: finance_apis/accounting.py
# # =====================================
# %%writefile modules/finance_apis/accounting.py
# import requests, os
# def get_balance():
#     api_key = os.getenv("ALPHA_VANTAGE_API_KEY")
#     url = f"https://www.alphavantage.co/query?function=BALANCE_SHEET&symbol=AAPL&apikey={api_key}"
#     response = requests.get(url)
#     data = response.json()
#     try:
#         report = data['annualReports'][0]
#         balance = report['cashAndCashEquivalentsAtCarryingValue']
#         return {"account_balance": f"${balance}"}
#     except Exception as e:
#         return {"error": str(e)}

# Commented out IPython magic to ensure Python compatibility.
# # ‚úÖ modules/finance_apis/tax_reporting.py
# %%writefile modules/finance_apis/tax_reporting.py
# import sqlite3, os
# from datetime import datetime
# from fpdf import FPDF
# import pandas as pd
# import re
# 
# def sanitize_column_name(name):
#     """Convert to SQLite-compatible snake_case column name."""
#     return re.sub(r'\W+', '_', str(name).strip().lower())
# 
# def parse_excel_to_db(file_path, db_path="data/financial_data.db"):
#     df = pd.read_excel(file_path)
#     original_columns = df.columns
#     sanitized_columns = [sanitize_column_name(col) for col in original_columns]
#     df.columns = sanitized_columns
# 
#     timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
#     table_name = f"financial_data_{timestamp}"
# 
#     conn = sqlite3.connect(db_path)
#     cursor = conn.cursor()
# 
#     # Create dynamic SQL table
#     columns_sql = ", ".join([f"`{col}` TEXT" for col in sanitized_columns])
#     create_sql = f"CREATE TABLE IF NOT EXISTS `{table_name}` (id INTEGER PRIMARY KEY AUTOINCREMENT, {columns_sql})"
#     cursor.execute(create_sql)
# 
#     df.to_sql(table_name, conn, if_exists='append', index=False)
#     conn.commit()
#     conn.close()
#     return table_name
# 
# def find_latest_excel(folder="data/uploaded_files"):
#     files = [f for f in os.listdir(folder) if f.endswith(".xlsx")]
#     if not files:
#         return None
#     files.sort(reverse=True)
#     return os.path.join(folder, files[0])
# 
# def generate_report():
#     db_path = "data/financial_data.db"
#     uploads_folder = "data/uploaded_files"  # Changed to the correct folder
#     pdf_folder = "pdf_reports"
# 
#     # Step 1: Get the latest Excel file
#     latest_excel = find_latest_excel(uploads_folder)
#     if not latest_excel:
#         return {"error": "No Excel files found in uploads folder."}
# 
#     # Step 2: Parse and save to DB
#     table_name = parse_excel_to_db(latest_excel, db_path)
# 
#     # Step 3: Fetch data
#     conn = sqlite3.connect(db_path)
#     cursor = conn.cursor()
#     cursor.execute(f"SELECT * FROM `{table_name}` LIMIT 5")
#     rows = cursor.fetchall()
#     columns = [description[0] for description in cursor.description]
#     conn.close()
# 
#     # Step 4: Generate PDF
#     if not os.path.exists(pdf_folder):
#         os.makedirs(pdf_folder)
#     filename = f"{pdf_folder}/tax_report_{datetime.now().strftime('%Y%m%d_%H%M%S')}.pdf"
# 
#     pdf = FPDF()
#     pdf.add_page()
#     pdf.set_font("Arial", size=12)
#     pdf.cell(200, 10, txt="Tax Report", ln=True, align="C")
# 
#     # Header
#     for col in columns:
#         pdf.cell(40, 10, txt=str(col), border=1)
#     pdf.ln()
# 
#     # Rows
#     for row in rows:
#         for val in row:
#             pdf.cell(40, 10, txt=str(val), border=1)
#         pdf.ln()
# 
#     pdf.output(filename)
# 
#     return {"status": "Report generated", "link": f"/{filename}", "table_name": table_name}
#

# Commented out IPython magic to ensure Python compatibility.
# # ‚úÖ 12. MODULE: api_handler.py
# # ===============================
# %%writefile modules/api_handler.py
# from modules.finance_apis import cash_management, accounting, tax_reporting
# def handle_api_call(intent):
#     if intent == "get_cashflow_summary":
#         return cash_management.get_summary()
#     elif intent == "generate_tax_report":
#         return tax_reporting.generate_report()
#     elif intent == "get_account_balance":
#         return accounting.get_balance()
#     else:
#         return {"error": "Unknown intent"}

# Commented out IPython magic to ensure Python compatibility.
# # ‚úÖ 13. MODULE: sql_loader.py
# # =================================
# %%writefile modules/sql_loader.py
# from langchain.schema import Document
# import sqlite3
# 
# def load_table_data(table_name: str):
#     conn = sqlite3.connect("data/financial_data.db")
#     cursor = conn.cursor()
# 
#     # Get column names
#     cursor.execute(f"PRAGMA table_info({table_name})")
#     columns_info = cursor.fetchall()
#     column_names = [col[1] for col in columns_info if col[1] != "id"]
# 
#     # Fetch all rows
#     cursor.execute(f"SELECT * FROM {table_name}")
#     rows = cursor.fetchall()
# 
#     documents = []
#     for row in rows:
#         row_dict = dict(zip(column_names, row[1:]))  # Skip the ID column
#         page_content = "\n".join([f"{k}: {v}" for k, v in row_dict.items()])
#         documents.append(Document(page_content=page_content, metadata={"source_table": table_name}))
# 
#     conn.close()
#     return documents
#

# Commented out IPython magic to ensure Python compatibility.
# %%writefile modules/__init__.py
# # This file marks the 'modules' folder as a Python package

# Commented out IPython magic to ensure Python compatibility.
# %%writefile modules/finance_apis/__init__.py
# # This file marks the 'finance_apis' folder as a sub-package

# Commented out IPython magic to ensure Python compatibility.
# %%writefile logs/__init__.py
# # This file marks the 'logs' folder as a Python package

import os
import shutil
from modules.speech_to_text import transcribe_audio
from modules.intent_recognizer import get_intent
from modules.api_handler import handle_api_call
from logs.logger import log_to_db
from modules.rag_retriever import (
    query_vector_store,
    setup_vector_store,
    load_vector_store,
    save_vector_store
)
from modules.file_parser import parse_and_store
from langchain.schema import Document
import sqlite3

#‚úÖ STEP 0: Upload and parse Excel/CSV file (Optional)
from google.colab import files
uploaded = files.upload()
#‚úÖ Initialize saved_path before the loop to avoid NameError if no files are uploaded
saved_path = None
for fname in uploaded.keys():
    print(f"‚úÖ File uploaded: {fname}")
    saved_path = f"/content/data/uploaded_files/{fname}"
    shutil.move(fname, saved_path)

# ‚úÖ STEP 1: Parse and store table (If file was uploaded)
if saved_path and saved_path.endswith((".xlsx", ".xls", ".csv")):
    target_table = parse_and_store(saved_path)
    print(f"‚úÖ Parsed and saved to DB table: {target_table}")
else:
    print("‚ö†Ô∏è No file uploaded or unsupported format. Proceeding without file-based data.")

# ‚úÖ STEP 2: Audio Input
audio_path = "/content/data/uploaded_files/get_account_balance.mp3"
if os.path.exists(audio_path):
    query = transcribe_audio(audio_path)
    print("üó£Ô∏è Transcribed Query:", query)

    intent = get_intent(query)
    print("üîç Detected Intent:", intent)

    # ‚úÖ Handle known API-based financial intents
    if intent in ["get_cashflow_summary", "generate_tax_report", "get_account_balance"]:
        response = handle_api_call(intent)
        # If tax report and no file was uploaded, inform the user
        if intent == "generate_tax_report" and not saved_path:
            response = {"error": "No file uploaded for tax report generation."}

    # ‚úÖ Otherwise, use RAG system (FAISS) if a file was uploaded and parsed
    elif saved_path:
        print("üì° Using RAG system for intelligent retrieval...")

        def load_table_data(table_name):
            conn = sqlite3.connect("data/financial_data.db")
            cursor = conn.cursor()
            cursor.execute(f"SELECT question, description FROM `{table_name}`")
            rows = cursor.fetchall()
            conn.close()
            return [Document(page_content=desc, metadata={"question": q}) for q, desc in rows]

        # ‚úÖ Try loading saved vector index
        vector_store = load_vector_store()

        if not vector_store:
            print("‚ö†Ô∏è No saved FAISS index found. Rebuilding...")
            documents = load_table_data(target_table)
            vector_store = setup_vector_store(documents)
            save_vector_store(vector_store)
            print("‚úÖ FAISS index rebuilt and saved.")
        else:
            print("‚úÖ Loaded FAISS index successfully.")

        answer = query_vector_store(query, vector_store)
        response = {"rag_answer": answer}
    else:
        response = {"error": "Unknown intent and no file uploaded for RAG."}

    log_to_db(intent, query, response)
    print("‚úÖ Final Response:", response)
else:
    print(f"‚ö†Ô∏è No audio file found at: {audio_path}")

import os
import shutil
from modules.speech_to_text import transcribe_audio
from modules.intent_recognizer import get_intent
from modules.api_handler import handle_api_call
from logs.logger import log_to_db
from modules.rag_retriever import (
    query_vector_store,
    setup_vector_store,
    load_vector_store,
    save_vector_store
)
from modules.file_parser import parse_and_store
from langchain.schema import Document
import sqlite3

#‚úÖ STEP 0: Upload and parse Excel/CSV file (Optional)
from google.colab import files
uploaded = files.upload()
#‚úÖ Initialize saved_path before the loop to avoid NameError if no files are uploaded
saved_path = None
for fname in uploaded.keys():
    print(f"‚úÖ File uploaded: {fname}")
    saved_path = f"/content/data/uploaded_files/{fname}"
    shutil.move(fname, saved_path)

# ‚úÖ STEP 1: Parse and store table (If file was uploaded)
if saved_path and saved_path.endswith((".xlsx", ".xls", ".csv")):
    target_table = parse_and_store(saved_path)
    print(f"‚úÖ Parsed and saved to DB table: {target_table}")
else:
    print("‚ö†Ô∏è No file uploaded or unsupported format. Proceeding without file-based data.")

# ‚úÖ STEP 2: Audio Input
audio_path = "/content/data/uploaded_files/generate_tax_report.mp3"
if os.path.exists(audio_path):
    query = transcribe_audio(audio_path)
    print("üó£Ô∏è Transcribed Query:", query)

    intent = get_intent(query)
    print("üîç Detected Intent:", intent)

    # ‚úÖ Handle known API-based financial intents
    if intent in ["get_cashflow_summary", "generate_tax_report", "get_account_balance"]:
        response = handle_api_call(intent)
        # If tax report and no file was uploaded, inform the user
        if intent == "generate_tax_report" and not saved_path:
            response = {"error": "No file uploaded for tax report generation."}

    # ‚úÖ Otherwise, use RAG system (FAISS) if a file was uploaded and parsed
    elif saved_path:
        print("üì° Using RAG system for intelligent retrieval...")

        def load_table_data(table_name):
            conn = sqlite3.connect("data/financial_data.db")
            cursor = conn.cursor()
            cursor.execute(f"SELECT question, description FROM `{table_name}`")
            rows = cursor.fetchall()
            conn.close()
            return [Document(page_content=desc, metadata={"question": q}) for q, desc in rows]

        # ‚úÖ Try loading saved vector index
        vector_store = load_vector_store()

        if not vector_store:
            print("‚ö†Ô∏è No saved FAISS index found. Rebuilding...")
            documents = load_table_data(target_table)
            vector_store = setup_vector_store(documents)
            save_vector_store(vector_store)
            print("‚úÖ FAISS index rebuilt and saved.")
        else:
            print("‚úÖ Loaded FAISS index successfully.")

        answer = query_vector_store(query, vector_store)
        response = {"rag_answer": answer}
    else:
        response = {"error": "Unknown intent and no file uploaded for RAG."}

    log_to_db(intent, query, response)
    print("‚úÖ Final Response:", response)
else:
    print(f"‚ö†Ô∏è No audio file found at: {audio_path}")

import os
import sqlite3
from modules.speech_to_text import transcribe_audio
from modules.rag_retriever import query_vector_store, load_vector_store, setup_vector_store
from logs.logger import log_to_db
from langchain.schema import Document

# üìç Config
audio_path = "/content/data/uploaded_files/q_frm_tax_data.mp3"
target_table = "financial_data_20250422_222438"
db_path = "data/financial_data.db"


def load_table_documents(table_name):
    """Loads data from the specified table and creates Langchain Documents."""
    conn = sqlite3.connect(db_path)
    cursor = conn.cursor()
    cursor.execute(f"SELECT * FROM `{table_name}`")
    rows = cursor.fetchall()
    column_names = [desc[0] for desc in cursor.description]
    conn.close()

    documents = []
    for row in rows:
        row_dict = dict(zip(column_names, row))
        if all(value in (None, "", " ") for value in row_dict.values()):
            continue
        row_text = f"Row Details:\n" + "\n".join([f"{k}: {v}" for k, v in row_dict.items()])
        doc = Document(page_content=row_text, metadata=row_dict)
        documents.append(doc)

    return documents


def format_full_row(metadata):
    return (
        "\n".join([f"{k}: {v}" for k, v in metadata.items()])
        if metadata
        else "‚ö†Ô∏è No matching row found."
    )


if os.path.exists(audio_path):
    query = transcribe_audio(audio_path)
    print("üó£Ô∏è Transcribed Query:", query)

    vector_store = load_vector_store()

    if not vector_store:
        print("üì¶ Vector store not found. Generating and saving from table data...")
        documents = load_table_documents(target_table)
        vector_store = setup_vector_store(documents, save_index=True)

    matched_doc = query_vector_store(query, vector_store)

    if isinstance(matched_doc, str):
        final_answer = matched_doc
    else:
        matched_id = matched_doc.metadata.get("id")
        matched_question = matched_doc.metadata.get("Question")

        documents = load_table_documents(target_table)  # Ensure we have full table for filtering
        matching_rows = [doc.metadata for doc in documents if doc.metadata.get("Question") == matched_question]

        row_summary = {
            "id": matched_id,
            "Description": "",
            "Tax Rate (%)": ""
        }

        for row in matching_rows:
            desc = row.get("Description", "")
            if "employee salary" in desc.lower():
                row_summary["Description"] = desc
            if "tax rate" in desc.lower() or "%" in desc:
                row_summary["Tax Rate (%)"] = desc

        if not row_summary["Description"]:
            for row in matching_rows:
                if row.get("Description") and "expense" in row["Description"].lower():
                    row_summary["Description"] = row["Description"]
                    break

        final_answer = f"id: {row_summary['id']} | Description: {row_summary['Description']} | Tax Rate (%): {row_summary['Tax Rate (%)']}"

    response = {"rag_answer": final_answer}
    log_to_db(intent="dynamic_table_query", input_text=query, response=response)
    print("‚úÖ Final Response:", response)

else:
    print(f"‚ö†Ô∏è No audio file found at: {audio_path}")

#--------------------------   RAG  --------------------------------#
## ---------------------- RAG Random Question -------------------------------- ##

from modules.speech_to_text import transcribe_audio
from modules.intent_recognizer import get_intent
from modules.rag_retriever import load_vector_store, query_vector_store, setup_general_vector_store
from logs.logger import log_to_db
import os

# ‚úÖ STEP 1: Audio Input
audio_path = "/content/data/uploaded_files/random_question_1.mp3"
if os.path.exists(audio_path):
    query = transcribe_audio(audio_path)
    print("üó£Ô∏è Transcribed Query:", query)

    intent = get_intent(query)
    print("üîç Detected Intent:", intent)

    # ‚úÖ Use General Finance RAG system
    print("üì° Using General Finance RAG system...")

    vector_store = setup_general_vector_store()

    final_answer = query_vector_store(query, vector_store, k=3)  # Get plain string answer

    response = {"rag_answer": final_answer}
    log_to_db(intent, query, response)
    print("‚úÖ Final Response:", response)
else:
    print(f"‚ö†Ô∏è No audio file found at: {audio_path}")

from modules.speech_to_text import transcribe_audio
from modules.intent_recognizer import get_intent
from modules.rag_retriever import load_vector_store, query_vector_store, setup_general_vector_store
from logs.logger import log_to_db
import os

# ‚úÖ STEP 1: Audio Input
audio_path = "/content/data/uploaded_files/random_question.mp3"
if os.path.exists(audio_path):
    query = transcribe_audio(audio_path)
    print("üó£Ô∏è Transcribed Query:", query)

    intent = get_intent(query)
    print("üîç Detected Intent:", intent)

    # ‚úÖ Use General Finance RAG system
    print("üì° Using General Finance RAG system...")

    vector_store = setup_general_vector_store()

    final_answer = query_vector_store(query, vector_store, k=3)  # Get plain string answer

    response = {"rag_answer": final_answer}
    log_to_db(intent, query, response)
    print("‚úÖ Final Response:", response)
else:
    print(f"‚ö†Ô∏è No audio file found at: {audio_path}")

#------------------- cashflow ----------------------------


import os
import shutil
from modules.speech_to_text import transcribe_audio
from modules.intent_recognizer import get_intent
from modules.api_handler import handle_api_call
from logs.logger import log_to_db
from modules.rag_retriever import (
    query_vector_store,
    setup_vector_store,
    load_vector_store,
    save_vector_store
)
from modules.file_parser import parse_and_store
from langchain.schema import Document
import sqlite3

#‚úÖ STEP 0: Upload and parse Excel/CSV file (Optional)
from google.colab import files
uploaded = files.upload()
#‚úÖ Initialize saved_path before the loop to avoid NameError if no files are uploaded
saved_path = None
for fname in uploaded.keys():
    print(f"‚úÖ File uploaded: {fname}")
    saved_path = f"/content/data/uploaded_files/{fname}"
    shutil.move(fname, saved_path)

# ‚úÖ STEP 1: Parse and store table (If file was uploaded)
if saved_path and saved_path.endswith((".xlsx", ".xls", ".csv")):
    target_table = parse_and_store(saved_path)
    print(f"‚úÖ Parsed and saved to DB table: {target_table}")
else:
    print("‚ö†Ô∏è No file uploaded or unsupported format. Proceeding without file-based data.")

# ‚úÖ STEP 2: Audio Input
audio_path = "/content/data/uploaded_files/get_cashflow_summary.mp3"
if os.path.exists(audio_path):
    query = transcribe_audio(audio_path)
    print("üó£Ô∏è Transcribed Query:", query)

    intent = get_intent(query)
    print("üîç Detected Intent:", intent)

    # ‚úÖ Handle known API-based financial intents
    if intent in ["get_cashflow_summary", "generate_tax_report", "get_account_balance"]:
        response = handle_api_call(intent)
        # If tax report and no file was uploaded, inform the user
        if intent == "generate_tax_report" and not saved_path:
            response = {"error": "No file uploaded for tax report generation."}

    # ‚úÖ Otherwise, use RAG system (FAISS) if a file was uploaded and parsed
    elif saved_path:
        print("üì° Using RAG system for intelligent retrieval...")

        def load_table_data(table_name):
            conn = sqlite3.connect("data/financial_data.db")
            cursor = conn.cursor()
            cursor.execute(f"SELECT question, description FROM `{table_name}`")
            rows = cursor.fetchall()
            conn.close()
            return [Document(page_content=desc, metadata={"question": q}) for q, desc in rows]

        # ‚úÖ Try loading saved vector index
        vector_store = load_vector_store()

        if not vector_store:
            print("‚ö†Ô∏è No saved FAISS index found. Rebuilding...")
            documents = load_table_data(target_table)
            vector_store = setup_vector_store(documents)
            save_vector_store(vector_store)
            print("‚úÖ FAISS index rebuilt and saved.")
        else:
            print("‚úÖ Loaded FAISS index successfully.")

        answer = query_vector_store(query, vector_store)
        response = {"rag_answer": answer}
    else:
        response = {"error": "Unknown intent and no file uploaded for RAG."}

    log_to_db(intent, query, response)
    print("‚úÖ Final Response:", response)
else:
    print(f"‚ö†Ô∏è No audio file found at: {audio_path}")

#------------------- cashflow ----------------------------


import os
import shutil
from modules.speech_to_text import transcribe_audio
from modules.intent_recognizer import get_intent
from modules.api_handler import handle_api_call
from logs.logger import log_to_db
from modules.rag_retriever import (
    query_vector_store,
    setup_vector_store,
    load_vector_store,
    save_vector_store
)
from modules.file_parser import parse_and_store
from langchain.schema import Document
import sqlite3

#‚úÖ STEP 0: Upload and parse Excel/CSV file (Optional)
from google.colab import files
uploaded = files.upload()
#‚úÖ Initialize saved_path before the loop to avoid NameError if no files are uploaded
saved_path = None
for fname in uploaded.keys():
    print(f"‚úÖ File uploaded: {fname}")
    saved_path = f"/content/data/uploaded_files/{fname}"
    shutil.move(fname, saved_path)

# ‚úÖ STEP 1: Parse and store table (If file was uploaded)
if saved_path and saved_path.endswith((".xlsx", ".xls", ".csv")):
    target_table = parse_and_store(saved_path)
    print(f"‚úÖ Parsed and saved to DB table: {target_table}")
else:
    print("‚ö†Ô∏è No file uploaded or unsupported format. Proceeding without file-based data.")

# ‚úÖ STEP 2: Audio Input
audio_path = "/content/data/uploaded_files/get_cashflow_summary.mp3"
if os.path.exists(audio_path):
    query = transcribe_audio(audio_path)
    print("üó£Ô∏è Transcribed Query:", query)

    intent = get_intent(query)
    print("üîç Detected Intent:", intent)

    # ‚úÖ Handle known API-based financial intents
    if intent in ["get_cashflow_summary", "generate_tax_report", "get_account_balance"]:
        response = handle_api_call(intent)
        # If tax report and no file was uploaded, inform the user
        if intent == "generate_tax_report" and not saved_path:
            response = {"error": "No file uploaded for tax report generation."}

    # ‚úÖ Otherwise, use RAG system (FAISS) if a file was uploaded and parsed
    elif saved_path:
        print("üì° Using RAG system for intelligent retrieval...")

        def load_table_data(table_name):
            conn = sqlite3.connect("data/financial_data.db")
            cursor = conn.cursor()
            cursor.execute(f"SELECT question, description FROM `{table_name}`")
            rows = cursor.fetchall()
            conn.close()
            return [Document(page_content=desc, metadata={"question": q}) for q, desc in rows]

        # ‚úÖ Try loading saved vector index
        vector_store = load_vector_store()

        if not vector_store:
            print("‚ö†Ô∏è No saved FAISS index found. Rebuilding...")
            documents = load_table_data(target_table)
            vector_store = setup_vector_store(documents)
            save_vector_store(vector_store)
            print("‚úÖ FAISS index rebuilt and saved.")
        else:
            print("‚úÖ Loaded FAISS index successfully.")

        answer = query_vector_store(query, vector_store)
        response = {"rag_answer": answer}
    else:
        response = {"error": "Unknown intent and no file uploaded for RAG."}

    log_to_db(intent, query, response)
    print("‚úÖ Final Response:", response)
else:
    print(f"‚ö†Ô∏è No audio file found at: {audio_path}")

#!cd /content && zip -r ai_finance_agent.zip . -i ai_finance_agent

!mkdir /content/ai_finance_agent

!mv /content/audio_samples /content/ai_finance_agent/
!mv /content/data /content/ai_finance_agent/
!mv /content/logs /content/ai_finance_agent/
!mv /content/modules /content/ai_finance_agent/
!mv /content/pdf_reports /content/ai_finance_agent/

!mv /content/Financial_AI_Agent_.ipynb /content/ai_finance_agent/

!ls /content